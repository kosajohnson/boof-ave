<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BOOF Ave – Interactive Prototype</title>
  <style>
    html, body { height: 100%; margin: 0; background:#151515; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #ui {
      position: fixed; left: 12px; top: 12px; z-index: 10; color: #fff;
      background: rgba(0,0,0,.55); padding: 10px 12px; border-radius: 12px; backdrop-filter: blur(6px);
      box-shadow: 0 6px 18px rgba(0,0,0,.35);
    }
    #ui label { margin-right: 10px; font-size: 14px; }
    #help { font-size: 12px; opacity: .85; margin-top: 6px; }
    canvas { display:block; width:100%; height:100%; image-rendering: pixelated; }
    .tooltip {
      position: fixed; left: 0; top: 0; transform: translate(-50%,-140%);
      padding: 6px 8px; font-size: 12px; color: #fff; background: rgba(0,0,0,.8);
      border-radius: 8px; pointer-events: none; display: none; z-index: 11;
    }
    a { color:#aee; }
  </style>
</head>
<body>
  <div id="ui">
    <strong>BOOF Ave — Prototype</strong><br>
    <label><input type="checkbox" id="toggleNight"> Night</label>
    <label> Pixel scale
      <input type="range" id="pixelScale" min="1.0" max="2.0" step="0.1" value="1.4">
    </label>
    <div id="help">Click scene to lock mouse · WASD to move · Click door/sign/planter</div>
  </div>
  <div id="tip" class="tooltip"></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.1/build/three.module.js';
    import { PointerLockControls } from 'https://unpkg.com/three@0.160.1/examples/jsm/controls/PointerLockControls.js';

    // --- core ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x6ea2c6); // subtle sky tint (era-style)

    const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 100);
    camera.position.set(0, 1.7, 8);

    const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference:'low-power' });
    document.body.appendChild(renderer.domElement);

    // pixel-scale (era vibe)
    const pixelSlider = document.getElementById('pixelScale');
    function resize() {
      const s = parseFloat(pixelSlider.value);
      renderer.setSize(innerWidth / s, innerHeight / s, false);
      renderer.domElement.style.width  = '100%';
      renderer.domElement.style.height = '100%';
      renderer.domElement.style.imageRendering = 'pixelated';
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize);
    pixelSlider.addEventListener('input', resize);
    resize();

    // --- lights (Lambert/Phong = mid-2000s look) ---
    const hemi = new THREE.HemisphereLight(0xdedede, 0x404040, 0.8);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xffffff, 1.15);
    sun.position.set(4, 8, 6);
    sun.castShadow = false; // blob-ish era vibe (no soft PBR shadows)
    scene.add(sun);

    // street lamp light (night mode)
    const lampLight = new THREE.PointLight(0xffe09b, 0, 10, 2.0); // start off
    lampLight.position.set(-5.2, 3.6, 1.3);
    scene.add(lampLight);

    // --- ground / street ---
    const groundMat = new THREE.MeshLambertMaterial({ color: 0x7a6e62 });
    const sidewalkMat = new THREE.MeshLambertMaterial({ color: 0x9b8e82 });
    const curbMat = new THREE.MeshLambertMaterial({ color: 0x6d6257 });

    const street = new THREE.Mesh(new THREE.PlaneGeometry(30, 30), groundMat);
    street.rotation.x = -Math.PI/2;
    street.position.y = 0;
    scene.add(street);

    const sidewalk = new THREE.Mesh(new THREE.BoxGeometry(18, 0.2, 6), sidewalkMat);
    sidewalk.position.set(0, 0.1, 0);
    scene.add(sidewalk);

    const curb = new THREE.Mesh(new THREE.BoxGeometry(18, 0.1, 0.4), curbMat);
    curb.position.set(0, 0.15, -3.2);
    scene.add(curb);

    // --- palette helpers ---
    const GREEN = 0x285c3e;  // doors/trim
    const BEIGE = 0xc8b59e;  // facade stone
    const BRICK = 0xb1896b;

    // --- building group (very modular, low-mid poly) ---
    const building = new THREE.Group();
    scene.add(building);

    // main block
    const facadeMat = new THREE.MeshLambertMaterial({ color: BEIGE });
    const brickMat  = new THREE.MeshLambertMaterial({ color: BRICK });
    const trimMat   = new THREE.MeshLambertMaterial({ color: 0xa48a6d });
    const greenMat  = new THREE.MeshPhongMaterial({ color: GREEN, shininess: 12, specular: 0x222222 });

    const blockL = new THREE.Mesh(new THREE.BoxGeometry(8, 5.5, 1), facadeMat);
    blockL.position.set(-2.5, 2.9, -2.2);
    building.add(blockL);

    const blockR = new THREE.Mesh(new THREE.BoxGeometry(6, 5.5, 1), brickMat);
    blockR.position.set(5, 2.9, -2.2);
    building.add(blockR);

    // steps
    function addStep(w, h, d, y, z){
      const s = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), sidewalkMat);
      s.position.set(0, y, z);
      building.add(s);
    }
    addStep(3.9, 0.25, 1.0, 0.25, -1.2);
    addStep(3.6, 0.25, 1.0, 0.50, -0.4);
    addStep(3.3, 0.25, 1.0, 0.75,  0.4);

    // door frame
    const frame = new THREE.Mesh(new THREE.BoxGeometry(3.0, 3.6, 0.2), trimMat);
    frame.position.set(0, 2.0, -1.6);
    building.add(frame);

    // door leaf with hinge (separate pivot for anim)
    const doorPivot = new THREE.Object3D();
    doorPivot.position.set(-1.48, 1.4, -1.49);
    building.add(doorPivot);

    const door = new THREE.Mesh(new THREE.BoxGeometry(3.0, 2.8, 0.06), greenMat);
    // shift so its left edge sits on pivot (simulates hinge)
    door.position.set(1.5, 0, 0);
    doorPivot.add(door);

    // windows (very stylized)
    function addWindow(x, y){
      const w = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.6, 0.08), new THREE.MeshLambertMaterial({ color: 0x5b7a8a }));
      w.position.set(x, y, -1.52);
      building.add(w);
      const trim = new THREE.Mesh(new THREE.BoxGeometry(1.45, 1.85, 0.05), trimMat);
      trim.position.set(x, y, -1.53);
      building.add(trim);
    }
    addWindow(-3.5, 3.8); addWindow(-0.6, 3.8); addWindow(2.3, 3.8);
    addWindow(-3.5, 1.9); addWindow(-0.6, 1.9); addWindow(2.3, 1.9);

    // fire escape (simple)
    const fePlatform = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.12, 1.0), new THREE.MeshLambertMaterial({ color: 0x7a4c34 }));
    fePlatform.position.set(6.5, 3.7, -1.7);
    building.add(fePlatform);
    const feStairs = new THREE.Mesh(new THREE.BoxGeometry(0.25, 2.0, 1.0), new THREE.MeshLambertMaterial({ color: 0x7a4c34 }));
    feStairs.position.set(5.7, 2.7, -1.7);
    feStairs.rotation.z = -0.9;
    building.add(feStairs);

    // planters
    function planter(x,z){
      const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.45,0.55,0.5,8), new THREE.MeshLambertMaterial({ color: 0x9b6a42 }));
      pot.position.set(x, 0.25, z);
      scene.add(pot);
      const foliage = new THREE.Mesh(new THREE.IcosahedronGeometry(0.45, 0), new THREE.MeshLambertMaterial({ color: 0x2e7d43 }));
      foliage.position.set(x, 0.7, z);
      foliage.userData = { tip:'Water geraniums', type:'plant' };
      scene.add(foliage);
      interactables.push(foliage);
    }
    planter(-1.8, -1.1);
    planter( 2.0, -1.1);

    // street sign + lamp
    const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.12,4.3,12), new THREE.MeshLambertMaterial({ color: 0x1e5736 }));
    pole.position.set(-5.2, 2.15, 1.3);
    scene.add(pole);

    const globe = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 12), new THREE.MeshLambertMaterial({ color: 0xf7f0dc }));
    globe.position.set(-5.2, 4.1, 1.3);
    scene.add(globe);

    // sign board with canvas texture
    function makeSignTexture(textTop='123', textMain='BOOF', textSub='AVE'){
      const c = document.createElement('canvas');
      c.width = 512; c.height = 256;
      const g = c.getContext('2d');
      g.fillStyle = '#1e5736'; g.fillRect(0,0,512,256);
      g.lineWidth = 20; g.strokeStyle='#f2d27a'; g.strokeRect(10,10,492,236);
      g.fillStyle='#f9f7f0'; g.font = 'bold 120px Arial'; g.textAlign='left'; g.textBaseline='middle';
      g.fillText(textMain, 34, 132);
      g.font = 'bold 48px Arial'; g.fillText(textSub, 370, 210);
      g.font = 'bold 48px Arial'; g.fillText(textTop, 370, 52);
      return new THREE.CanvasTexture(c);
    }
    const signTex = makeSignTexture();
    const sign = new THREE.Mesh(new THREE.PlaneGeometry(2.7, 1.35), new THREE.MeshBasicMaterial({ map: signTex }));
    sign.position.set(-5.2, 2.2, 1.3);
    sign.rotation.y = Math.PI/2;
    sign.userData = { type:'sign', tip:'Change street number' };
    scene.add(sign);

    // green side door on right block (non-animated, click to ping)
    const sideDoor = new THREE.Mesh(new THREE.BoxGeometry(1.1, 2.2, 0.05), greenMat);
    sideDoor.position.set(7.8, 1.2, -1.5);
    sideDoor.userData = { type:'knock', tip:'Knock (placeholder)' };
    building.add(sideDoor);
    interactablesPush(sideDoor); // helper will add raycasting flag

    // --- interaction & controls ---
    const controls = new PointerLockControls(camera, renderer.domElement);
    document.body.addEventListener('click', () => controls.lock());
    controls.addEventListener('lock', ()=> tip.style.display='none');

    // simple WASD locomotion with bounds
    const keys = { w:false, a:false, s:false, d:false };
    window.addEventListener('keydown', e=> { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true; });
    window.addEventListener('keyup',   e=> { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; });

    const speed = 2.2;
    const worldBounds = { xMin:-9, xMax: 9, zMin:-6, zMax: 6 };

    // raycasting for clicks
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const interactables = [];
    function interactablesPush(obj){ obj.userData = obj.userData||{}; interactables.push(obj); }
    interactablesPush(door); interactablesPush(sign);

    renderer.domElement.addEventListener('mousemove', (ev)=>{
      // show small tooltip when hovering an interactable
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((ev.clientX - rect.left)/rect.width)*2 - 1;
      mouse.y = -((ev.clientY - rect.top)/rect.height)*2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects(interactables, false);
      const tip = document.getElementById('tip');
      if(hits[0]){
        const p = hits[0].object;
        tip.textContent = p.userData.tip || 'Interact';
        tip.style.left = ev.clientX + 'px';
        tip.style.top  = ev.clientY + 'px';
        tip.style.display = 'block';
      } else {
        tip.style.display = 'none';
      }
    });

    renderer.domElement.addEventListener('click', (ev)=>{
      // when locked, this click is for look; when unlocked, use raycast to act
      if(controls.isLocked) return;
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((ev.clientX - rect.left)/rect.width)*2 - 1;
      mouse.y = -((ev.clientY - rect.top)/rect.height)*2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects(interactables, false);
      if(!hits[0]) return;
      const o = hits[0].object;
      if(o === door){
        door.userData.open = !door.userData.open;
      } else if(o === sign){
        // flip between 123 and 10B as a nod to the render/demo
        const alt = sign.userData.alt = !(sign.userData.alt);
        sign.material.map = makeSignTexture(alt?'10B':'123', 'BOOF', 'AVE');
        sign.material.needsUpdate = true;
      } else if(o.userData.type === 'plant'){
        o.material.color.offsetHSL(0.03, 0.0, 0.0); // simple feedback
      }
    });

    // --- night toggle ---
    const nightToggle = document.getElementById('toggleNight');
    nightToggle.addEventListener('change', ()=>{
      const night = nightToggle.checked;
      sun.intensity  = night ? 0.05 : 1.15;
      hemi.intensity = night ? 0.25 : 0.8;
      lampLight.intensity = night ? 2.2 : 0.0;
      scene.background = new THREE.Color(night ? 0x0b1520 : 0x6ea2c6);
    });

    // --- game loop ---
    let last = performance.now();
    function loop(now){
      const dt = Math.min((now - last)/1000, 0.033);
      last = now;

      // movement
      if(controls.isLocked){
        const dir = new THREE.Vector3();
        camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
        const right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0)).normalize();
        const pos = controls.getObject().position;
        if(keys.w) pos.addScaledVector(dir,  speed*dt);
        if(keys.s) pos.addScaledVector(dir, -speed*dt);
        if(keys.a) pos.addScaledVector(right, -speed*dt);
        if(keys.d) pos.addScaledVector(right,  speed*dt);
        // bounds clamp
        pos.x = Math.max(worldBounds.xMin, Math.min(worldBounds.xMax, pos.x));
        pos.z = Math.max(worldBounds.zMin, Math.min(worldBounds.zMax, pos.z));
        pos.y = 1.7;
      }

      // animate door open/close
      const target = (door.userData.open ? -1.15 : 0);
      doorPivot.rotation.y += (target - doorPivot.rotation.y) * Math.min(1, dt*6);

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // place camera onto controls object
    scene.add(controls.getObject());
    controls.getObject().position.set(0, 1.7, 8);

    // initial hint
    const tip = document.getElementById('tip');
    tip.style.display = 'none';
  </script>
</body>
</html>
